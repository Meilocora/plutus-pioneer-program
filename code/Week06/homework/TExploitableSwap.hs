{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Plutus.Model         (Run, TypedValidator (TypedValidator),
                                       adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue, UserSpend, Tx,
                                       DatumMode (HashDatum), userSpend, payToScript, spendScript,
                                       payToKey, newUser, spend, submitTx, utxoAt, valueAt, logError)
import           PlutusTx.Prelude     (($), Integer, Eq ((==)), (&&))
import           Prelude              (IO, (.), (<>), Monoid (mconcat), Traversable (mapM), Num ((-)))
import qualified ExploitableSwap      as OnChain
import qualified PatchedSwap          as PatchedOnChain (validator)
import           Test.Tasty           (defaultMain, testGroup)
import           Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue))
import           Control.Monad (unless)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending using vulnerable script succeeds" $ normalSpending swapScript
      , good "Double spending using vulnerable script succeeds" $ doubleSpending swapScript
      , good "Normal spending using patched script succeeds   " $ normalSpending patchedSwapScript
      , bad  "Double spending using patched script fails      " $ doubleSpending patchedSwapScript
      ]
 where
    bad msg = good msg . mustFail -- mustFail... logs an error if everything succeeds, so if the tx fails there will be no error
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage
                        -- define how many values are on the mock blockchain
---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------
-- create the token
scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"

-- create the class "Homeworkscript" because there will be a swapScript and a patchedSwapScript 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

-- exploitable validator
swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

-- patched validator
patchedSwapScript :: HomeworkScript
patchedSwapScript = TypedValidator $ toV2 PatchedOnChain.validator

-- Create a transaction, that spends "usp" to lock "val" [wich will be the token] in the validator script
lockingTx :: HomeworkScript -> PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx script benef price usp val =
  mconcat -- combines multiple simple transactions into one complex transaction
    [ userSpend usp -- here everything that the user (beneficiary) has to spend for locking the transaction is specified
             -- usp... a parameter of type "UserSpend" that includes utxos of the user at the current state of the blockchain 
    , payToScript script (HashDatum (OnChain.DatumSwap benef price)) val  -- transaction to pay to the script
               -- validator script that we want to pay to
                       -- Datum of the validator
                                                                  -- value that we want to lock 
    ]

-- Create a transaction, that consumes the utxo with the token
consumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> Value -> Tx
consumingTx script benef price buyer sp2 ref token =
  mconcat
    [ spendScript script ref () (OnChain.DatumSwap benef price)
              -- validator script we want to spent
                      -- reference of the specific utxo we want to consume
                         -- redeemer we must provide to unlock the value
                                -- datum of the validator
    , payToKey buyer token  -- transaction to give the token to the user (buyer)
    , payToKey benef $ adaValue price -- transaction to give the spent ada from the user (buyer) to the beneficiary
    , userSpend sp2 -- transaction to make the user (buyer) pay  
    ]

-- Create a transaction, that consumes two utxo with one token each but only pays the price once
doubleConsumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> TxOutRef -> Value -> Tx
doubleConsumingTx script benef price buyer sp2 ref1 ref2 token =
  mconcat
    [ spendScript script ref1 () (OnChain.DatumSwap benef price)  -- transaction to spend the script
    , spendScript script ref2 () (OnChain.DatumSwap benef price)  -- transaction to spend the script again
    , payToKey buyer $ token <> token -- transaction to give two tokens to the user (buyer)
    , payToKey benef $ adaValue price -- transaction to give the spent ada from the user (buyer) to the beneficiary
    , userSpend sp2   -- transaction to make the user (buyer) pay 
    ]
    -- the user (buyer) only pays for one token because there is only one transaction to be payed for, but the tx includes two tx that spend a utxo with one token each
    -- only works when the beneficiary wants to sell 2 tokens with the same script


---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: HomeworkScript -> Run ()
normalSpending script = do
 -- Setup Users, only user 1 gets the initial super cool token
  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1)  -- User 1 gets 1000 Ada and 1 token
  u2 <- newUser (adaValue 1000)                         -- User 2 gets 1000 Ada
  -- USER 1 LOCKS TOKEN IN VALIDATOR
  let token = adaValue 1 <> fakeValue scToken 1       -- token = 1 Ada to transport a native token and 1 token
      price = 350
  sp1 <- spend u1 token       -- finds a utxo with 351 Ada and 1 token at the user1 address and binds it to "sp1"                  
  submitTx u1 $ lockingTx script u1 price sp1 token   -- transaction to lock the validator with the inputs from user1 is being submitted by user1
  -- USER 2 BUYS TOKEN
  utxos <- utxoAt script      -- finds the utxos at the script address and binds them to "utxos"
  -- logError $ show utxos
  let [(ref, out)] = utxos    -- patternmatch to extract the reference and the output from the utxo           
  sp2 <- spend u2 (adaValue price)    -- finds a utxo with 350 Ada at the user2 address and binds it to "sp2"                       
  submitTx u2 $ consumingTx script u1 price u2 sp2 ref (txOutValue out) -- transaction to use the consuming tx with the inputs from user1 is being submitted by user2 
  -- -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]   -- bind the current balances to v1 and v2      
  let expectedV1 = adaValue 999 <> adaValue price     -- check that user1 now hast 999 Ada + the price user2 payed to him
  let expectedV2 = adaValue (1000 - price) <> token   -- check that user2 now hast 1000 Ada - the price he payed to user1 and the token
  unless (v1 == expectedV1 && v2 == expectedV2) $ 
    logError "Final balances are incorrect"           -- Error message when it doesnt fit to the actual balances


doubleSpending :: HomeworkScript -> Run ()
doubleSpending script = do
  -- Setup Users, only user 1 gets the initial super cool token
  u1 <- newUser (adaValue 1000 <> fakeValue scToken 2)    -- User 1 gets 1000 Ada and 2 tokens
  u2 <- newUser (adaValue 1000)                           -- User 2 gets 1000 Ada
  -- USER 1 LOCKS TOKEN IN VALIDATOR TWICE
  let token = adaValue 1 <> fakeValue scToken 1           -- token = 1 Ada to transport a native token and 1 token
      price = 350
  sp1 <- spend u1 token         -- finds a utxo with 351 Ada and 1 token at the user1 address and binds it to "sp1"                  
  submitTx u1 $ lockingTx script u1 price sp1 token       -- transaction to lock the validator with the inputs from user1 is being submitted by user1
  sp1' <- spend u1 token        -- finds another utxo with 351 Ada and 1 token at the user1 address and binds it to "sp1'"                    
  submitTx u1 $ lockingTx script u1 price sp1' token      -- transaction to lock the validator with the inputs from user1 is being submitted by user1
  -- User 2 buys one token and steals another one 
  utxos <- utxoAt script        -- finds the utxos at the script address and binds them to "utxos"
  let [(ref1, out),(ref2, _)] = utxos    -- patternmatch to extract the references and the outputs from the utxos
                                         -- output from the second utxo doesnt matter because the value is the same but the ref is needed because it must be specified for the consuming tx             
  sp2 <- spend u2 (adaValue price)      -- finds a utxo with 350 Ada at the user2 address and binds it to "sp2"                     
  submitTx u2 $ doubleConsumingTx script u1 price u2 sp2 ref1 ref2 (txOutValue out)   -- transaction to use the consuming tx with the inputs from user1 is being submitted by user2
   -- Check that final balances match expected balances
  [v1, v2] <- mapM valueAt [u1, u2]     -- bind the current balances to v1 and v2   
  let expectedV1 = adaValue 998 <> adaValue price   -- check that user1 now hast 999 Ada + the price user2 payed to him
  let expectedV2 = adaValue (1000 - price) <> token <> token    -- check that user2 now hast 1000 Ada - the price he payed to user1 and two tokens
  unless (v1 == expectedV1 && v2 == expectedV2) $ 
    logError "Final balances are incorrect"   -- Error message when it doesnt fit to the actual balances

 -- use with:
-- cd code/Week06
-- cabal test week06-TExploitableSwap